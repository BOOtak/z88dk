include(`z88dk.m4')

dnl############################################################
dnl##       ZXN_CRT_769.M4 - RAM MODEL DOTN COMMAND          ##
dnl############################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;          zx spectrum nextos extended dot command          ;;
;;       generated by target/zxn/startup/zxn_crt_799.m4      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GLOBAL SYMBOLS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include "config_zxn_public.inc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CRT AND CLIB CONFIGURATION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include "../crt_defaults.inc"
include "crt_config.inc"
include(`../crt_rules.inc')
include(`zxn_rules.inc')

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SET UP MEMORY MODEL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include(`crt_memory_map.inc')

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; INSTANTIATE DRIVERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef CRT_OTERM_FONT_8X8

   PUBLIC CRT_OTERM_FONT_8X8
   EXTERN _font_8x8_zx_system
   defc CRT_OTERM_FONT_8X8 = _font_8x8_zx_system

endif

include(`../clib_instantiate_begin.m4')

ifelse(eval(M4__CRT_INCLUDE_DRIVER_INSTANTIATION == 0), 1,
`
   include(`driver/terminal/zx_01_input_kbd_inkey.m4')dnl
   m4_zx_01_input_kbd_inkey(_stdin, __i_fcntl_fdstruct_1, CRT_ITERM_TERMINAL_FLAGS, M4__CRT_ITERM_EDIT_BUFFER_SIZE, CRT_ITERM_INKEY_DEBOUNCE, CRT_ITERM_INKEY_REPEAT_START, CRT_ITERM_INKEY_REPEAT_RATE)dnl

   include(`driver/terminal/zx_01_output_char_32_tty_z88dk.m4')dnl
   m4_zx_01_output_char_32_tty_z88dk(_stdout, CRT_OTERM_TERMINAL_FLAGS, 0, 0, CRT_OTERM_WINDOW_X, CRT_OTERM_WINDOW_WIDTH, CRT_OTERM_WINDOW_Y, CRT_OTERM_WINDOW_HEIGHT, 0, CRT_OTERM_FONT_8X8, CRT_OTERM_TEXT_COLOR, CRT_OTERM_TEXT_COLOR_MASK, CRT_OTERM_BACKGROUND_COLOR)dnl

   include(`../m4_file_dup.m4')dnl
   m4_file_dup(_stderr, 0x80, __i_fcntl_fdstruct_1)dnl
',
`
   include(`crt_driver_instantiation.asm.m4')
')

include(`../clib_instantiate_end.m4')

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; STARTUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SECTION CODE

PUBLIC __Start, __Exit

EXTERN _main

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CRT INIT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

__Start:
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; returning to basic
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   IF __crt_enable_commandline >= 2
   
      ld (__command_line),bc
      
   ENDIF

   push iy
   exx
   push hl

   ld (__sp),sp

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; check for nextos
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   rst __ESX_RST_SYS
   defb __ESX_M_DOSVERSION

   ; return status statically initialized to this
   ;
   ; ld hl,error_msg_nextos
   ; ld (__return_status),hl
   
   jp c, error_nextos          ; if esxdos present
   
   or a
   jp nz, error_nextos         ; if nextos is in 48k mode

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; save current mmu state
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   ld hl,__z_saved_mmu_state
   
   EXTERN asm_zxn_read_mmu_state
   call   asm_zxn_read_mmu_state

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; save basic bank state
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ; this is assumed
   ; mmu2 10
   
   EXTERN asm_zxn_read_sysvar_bank_state
   call   asm_zxn_read_sysvar_bank_state
   
   ld (__z_saved_bank_state),hl

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; get handle to load rest of dot command
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   rst __ESX_RST_SYS
   defb __ESX_M_GETHANDLE

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; allocate and load pages
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   ld c,a                      ; c = file handle
   
   ld hl,(__z_page_table_sz)   ; num pages and num extra
   
   ld a,l
   add a,h
   ld b,a                      ; b = total number of pages
   
   jr z, alloc_cancel          ; if no pages are being allocated

   ld hl,__z_alloc_table
   ld e,0                      ; current page
   
alloc_loop:

   ld a,(hl)
   
   inc a
   jr z, alloc_not_used        ; 0xff indicates page not used
   
   push de                     ; save current page
   push hl                     ; save allocation table position
   push bc                     ; save num pages, file handle
   
   ld l,0xfe
   push hl                     ; indicate absolute page loaded
   
   cp __ZXNEXT_LAST_PAGE + 2
   
   ld hl,error_msg_malformed_alloc
   jp c, terminate             ; if alloc page is a physical page number
   
   inc a                       ; 0xfe indicates load into absolute page
   jr z, alloc_load

   pop hl                      ; junk absolute page indicator

   ld hl,__nextos_rc_bank_alloc + (__nextos_rc_banktype_zx * 256)

   exx

   ld de,__NEXTOS_IDE_BANK
   ld c,7
   
   rst __ESX_RST_SYS
   defb __ESX_M_P3DOS
   
   ld hl,error_msg_out_of_memory
   jp nc, terminate
   
   ; load 8k of dot command into page
   
   pop bc
   push bc                     ; b = counter, c = file handle
   push de                     ; save allocated page
   
   ld a,(__z_page_extra_sz)
   cp b
   
   jr nc, alloc_no_load        ; if this is an extra page

alloc_load:

   ld a,e                      ; basic's stack should be in high memory,
   mmu2 a                      ;   place allocated page in mmu2
   
   ld a,c
   ld hl,0x4000
   ld bc,0x2000
   
   rst __ESX_RST_SYS
   defb __ESX_F_READ
   
   ld l,a
   ld h,0
   
   mmu2 10
   
   jp c, terminate             ; if read error
   
   ld hl,0x2000
   sbc hl,bc
   
   ld hl,__ESX_EIO
   jp nz, terminate            ; if did not read 0x2000 bytes

alloc_no_load:

   pop de
   pop bc
   pop hl

   ; e = page number

   ld (hl),e
   pop de                      ; recover current page
   
alloc_not_used:

   inc hl
   inc e

   djnz alloc_loop

alloc_cancel:

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; merge allocated table into page table
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ld hl,(__z_page_table_sz)
   
   ld a,l
   add a,h
   ld b,a

   jr z, merge_cancel
   
   ld hl,__z_alloc_table
   ld de,__z_page_table

merge_loop:

   ld a,(hl)
   
   cp __ZXNEXT_LAST_PAGE + 1
   jr nc, merge_no

   ld (de),a

merge_no:

   inc de
   inc hl
   
   djnz merge_loop

merge_cancel:

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; restore mmu state after allocation
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ld hl,__z_saved_mmu_state
   
   EXTERN asm_zxn_write_mmu_state
   call   asm_zxn_write_mmu_state

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; parse command line to divmmc memory
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ld sp,DOTN_REGISTER_SP       ; move stack to divmmc memory

   IF __crt_enable_commandline = 1
   
      include "../crt_cmdline_empty.inc"
      
      ex de,hl
      
      ; de = argv
      ; bc = argc
   
   ENDIF
   
   IF __crt_enable_commandline = 2

      ld hl,(__command_line)
      
      ld a,h
      or l
      
      jr nz, copy_continue

      push hl                  ; command line length = 0
      push hl                  ; unprocessed command line = 0
      
      jr copy_cancel
      
   copy_continue:
      
      include "../crt_cmdline_esxdos_len.inc"
      
      ; de = command line
      ; bc = length (could be zero)
      
      inc bc                   ; include terminator in length
      
      ld hl,128
      
      EXTERN l_minu_bc_hl
      call   l_minu_bc_hl      ; place a cap on the length of the command line
      
      ld c,l
      ld b,h
      
      ld hl,DOTN_REGISTER_SP
      
      xor a
      sbc hl,bc
      
      ld sp,hl
      ex de,hl

      push bc                  ; command line length
      push de                  ; unprocessed command line

      ldir
      dec de

      ld (de),a                ; replace terminator with 0

   copy_cancel:
   
      pop bc
      pop de
      
      ; bc = unprocessed command line
      ; de = command line length including terminator
      
   ENDIF

   IF __crt_enable_commandline >= 3

      ld hl,(__command_line)
      
      include "crt_cmdline_esx.inc"
      
      ex de,hl
      
      ; de = argv
      ; bc = argc
      
   ENDIF

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; page main bank into memory
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ld hl,(__z_page_table+10)
   
   ld a,l
   mmu2 a

   ld a,h
   mmu3 a

   ld hl,(__z_page_table+4)
   
   ld a,l
   mmu4 a

   ld a,h
   mmu5 a

   ld hl,(__z_page_table+0)
   
   ld a,l
   mmu6 a

   ld a,h
   mmu7 a

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; move stack to main bank
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   IF __register_sp != -1

      include "../crt_init_sp.inc"

   ENDIF

   IF __crt_enable_commandline >= 1

      ; de = argv / command line length
      ; bc = argc / unprocessed zero terminated command line
      
      push de
      push bc
      
   ENDIF

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; register basic error intercept
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   EXTERN _esx_errh
   
   ld hl,__dotn_basic_error_intercept
   ld (_esx_errh),hl

   rst __ESX_RST_SYS
   defb __ESX_M_ERRH
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; program launch
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ; initialize data section

   include "../clib_init_data.inc"

   ; initialize bss section

   include "../clib_init_bss.inc"

   ; not normal to disable interrupts
   
   include "../crt_start_di.inc"

   ; interrupt mode
   
   include "../crt_set_interrupt_mode.inc"

SECTION code_crt_init          ; user and library initialization
SECTION code_crt_main

   ; call user program
   
   IF __crt_enable_commandline = 2

      pop hl                   ; hl = unprocessed zero terminated command line
      pop bc                   ; bc = command line length including terminator
      
      push bc
      push hl
   
   ELSE
   
      IF __crt_enable_commandline >= 1

         pop bc                ; bc = argc
         pop hl                ; hl = argv
         
         push hl
         push bc
         
      ENDIF

   ENDIF

   include "../crt_start_ei.inc"

   call _main                  ; hl = return status

error_basic:

   ; run exit stack

   IF __clib_exit_stack_size > 0
   
      EXTERN asm_exit
      jp     asm_exit          ; exit function jumps to __Exit
   
   ENDIF

__Exit:

   push hl                     ; save return status

SECTION code_crt_exit          ; user and library cleanup
SECTION code_crt_return

   ; close files
   
   include "../clib_close.inc"
   
   pop hl                      ; hl = return status

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; terminate
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

terminate:

   ld (__return_status),hl
   
   ld sp,DOTN_REGISTER_SP       ; stack to divmmc memory
   
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; restore banked state
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   mmu2 10
   
   ld hl,(__z_saved_bank_state)

   EXTERN asm_zxn_write_sysvar_bank_state
   EXTERN asm_zxn_write_bank_state
   
   call   asm_zxn_write_sysvar_bank_state
   call   asm_zxn_write_bank_state  ; 1ffd, 7ffd, dffd=0

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; restore mmu state
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   ld hl,__z_saved_mmu_state
   
   EXTERN asm_zxn_write_mmu_state
   call   asm_zxn_write_mmu_state
   
   ld sp,(__sp)                ; back to basic's stack

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; deallocate pages
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   
   ld hl,(__z_page_table_sz)   ; pages and extra
   
   ld a,l
   add a,h
   ld b,a                      ; b = total number of pages
   
   jr z, dealloc_cancel

   ld hl,__z_alloc_table
   
dealloc_loop:

   ld a,(hl)
   
   cp __ZXNEXT_LAST_PAGE + 1
   jr nc, dealloc_not_used

   push bc
   push hl
   
   ld e,a
   ld hl,__nextos_rc_bank_free + (__nextos_rc_banktype_zx * 256)

   exx

   ld de,__NEXTOS_IDE_BANK
   ld c,7
   
   rst __ESX_RST_SYS
   defb __ESX_M_P3DOS
   
   pop hl
   pop bc
   
dealloc_not_used:

   inc hl
   djnz dealloc_loop

dealloc_cancel:

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; return to basic
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

error_nextos:

   pop hl
   exx
   pop iy
   
   ld hl,(__return_status)

   include "../crt_exit_eidi.inc"

   ; If you exit with carry set and A<>0, the corresponding error code will be printed in BASIC.
   ; If carry set and A=0, HL should be pointing to a custom error message (with last char +$80 as END marker).
   ; If carry reset, exit cleanly to BASIC
      
   ld a,h
   or l
   ret z                       ; status == 0, no error
      
   scf
   ld a,l
      
   inc h
   dec h
      
   ret z                       ; status < 256, basic error code in status&0xff
      
   ld a,0                      ; status = & custom error message
   ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BASIC ERROR ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

__dotn_basic_error_intercept:

   ; basic error has occurred during a rst $10 or rst $18
   ; must free allocated pages and close open files
   
   ; enter :  a = basic error code - 1
   ;         de = return address to restart
   ;         (you can resume the program if you jump to this address)

   ld hl,error_msg_d_break
   
   cp __ERRB_D_BREAK_CONT_REPEATS - 1
   jp z, error_basic
   
   ld hl,__ESX_ENONSENSE
   jp error_basic

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; error messages
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

error_msg_nextos:

   defm "Requires NextOS 128", 'k'+0x80

error_msg_out_of_memory:

   defm "4 Out of memor", 'y'+0x80

error_msg_malformed_alloc:

   defm "Alloc Table Malforme", 'd'+0x80

error_msg_d_break:

   defm "D BREAK - no repea", 't'+0x80

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; RUNTIME VARS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

__command_line:   defw 0

__sp:             defw 0

__return_status:  defw error_msg_nextos

PUBLIC __z_saved_bank_state
PUBLIC __z_saved_mmu_state

__z_saved_bank_state:  defw 0
__z_saved_mmu_state:   defs 8

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; contiguous section filled in by appmake

__appmake_handle:

PUBLIC __z_page_table_sz
PUBLIC __z_page_extra_sz

__z_page_table_sz:   defb DOTN_LAST_PAGE + 1  ; must be in this order
__z_page_extra_sz:   defb DOTN_EXTRA_PAGES    ; must be in this order

PUBLIC __z_alloc_table

__z_alloc_table:     defs DOTN_LAST_PAGE + DOTN_EXTRA_PAGES + 1, 0xff

PUBLIC __z_page_table
PUBLIC __z_page_extra

__z_page_table:      defs DOTN_LAST_PAGE + 1  ; must be in this order
__z_page_extra:      defs DOTN_EXTRA_PAGES    ; must be in this order

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include "../clib_variables.inc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLIB STUBS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include "../clib_stubs.inc"
